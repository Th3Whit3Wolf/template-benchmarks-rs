use ructe::Ructe;
use std::{env, path::PathBuf};

#[cfg(feature = "make_md")]
use cargo_toml::{Dependency, Manifest};
#[cfg(feature = "make_md")]
use crates_io_api::{Crate, Error, SyncClient};
#[cfg(feature = "make_md")]
use std::{collections::BTreeMap, fs, path::Path, process::Command, thread, time::Duration};

#[cfg(feature = "make_md")]
const NOT_TEMPLATE_LIB: [&str; 9] = [
    "cargo_toml",
    "chrono",
    "crates_io_api",
    "criterion",
    "sailfish-macros",
    "serde",
    "serde_derive",
    "serde_json",
    "serde_yaml",
];

#[cfg(feature = "make_md")]
const HEADER_MD: &str = "# Rust template engine benchmarks

This repo tries to assess Rust template engine performance. Following the
download ratings from [crates.io](https://crates.io/categories/template-engine).

| Rank | Library | Description | Recent Downloads | Last Updated |
| :--- | :-----: | :---------- | ---------------: | :----------: |
";

fn main() {
    let in_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("templates_ructe");
    Ructe::from_env()
        .unwrap()
        .compile_templates(&in_dir)
        .expect("compile templates");

    #[cfg(feature = "make_md")]
    {
        let mut cargo_toml_path: PathBuf = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
        cargo_toml_path.push("Cargo.toml");
        let cargo_toml_data = Manifest::from_path(cargo_toml_path);
        let top_100_template_engines_crates = get_top_100_template_engines().unwrap();

        let msg = if let Ok(manifest) = cargo_toml_data {
            let mut m: String = HEADER_MD.to_string();
            let mut deps: BTreeMap<String, Dependency> = manifest.dependencies;
            for (name, kind) in manifest.build_dependencies {
                deps.insert(name, kind);
            }
            for num in 0..top_100_template_engines_crates.len() {
                if !NOT_TEMPLATE_LIB.contains(&top_100_template_engines_crates[num].name.as_str())
                    && deps
                        .remove_entry(&top_100_template_engines_crates[num].name)
                        .is_some()
                {
                    m.push_str(&crate_into_row(
                        Some(num + 1),
                        &top_100_template_engines_crates[num],
                    ))
                }
            }
            for (name, _) in deps {
                if !NOT_TEMPLATE_LIB.contains(&name.as_str()) {
                    let crate_info = get_crate_info(&name).unwrap();
                    m.push_str(&crate_into_row(None, &crate_info))
                }
            }
            let (rustc_vers, rustc_date) = get_version_and_date().unwrap();
            let rustc_vers = rustc_vers.unwrap();
            let rustc_date = rustc_date.unwrap();
            let date_as_str = rustc_date.split('-').collect::<Vec<&str>>();
            let dt = chrono::NaiveDate::from_ymd(
                date_as_str[0].parse::<i32>().unwrap(),
                date_as_str[1].parse::<u32>().unwrap(),
                date_as_str[2].parse::<u32>().unwrap(),
            );
            m.push_str(&format!(
                "| unranked | {} | {} | {} | {} |\n",
                "[write!](https://doc.rust-lang.org/std/macro.write.html)",
                "the std library `write!` macro",
                "a lot",
                dt.format("%d %B %Y")
            ));
            m.push_str(&format!("## Results

These results are from {} (rustc {}) on a GitHub Actions runner , which uses a Azure Standard_DS2_v2 virtual machine. 
For more information about the hardware used checkout [Microsoft Azure documentation](https://docs.microsoft.com/en-us/azure/virtual-machines/dv2-dsv2-series#dsv2-series).
Your mileage may vary.

As a [violin plot](https://en.wikipedia.org/wiki/Violin_plot) generated by [Criterion](https://japaric.github.io/criterion.rs/):

![Big table violin plot](big-table.svg)
![Teams violin plot](teams.svg)

Numbers, as output by Criterion:\n\n",
                chrono::Utc::now().format("%d %B %Y"),
                rustc_vers
                )
            );
            m
        } else {
            "Unable to read Cargo.toml\n".to_string()
        };

        let out_dir = env::var_os("CARGO_MANIFEST_DIR").unwrap();
        let dest_path = Path::new(&out_dir).join("new_README.md");
        fs::write(&dest_path, msg).unwrap();
    }
}

#[cfg(feature = "make_md")]
fn get_crate_info(crate_name: &str) -> Result<Crate, Error> {
    // Instantiate the client.
    let client = SyncClient::new(
        "template-benchmark-rs (the.white.wolf.is.1337@gmail.com)",
        std::time::Duration::from_millis(2000),
    )?;
    // Retrieve crate data.
    let crate_info = client.get_crate(crate_name)?;
    thread::sleep(Duration::from_secs(2));

    Ok(crate_info.crate_data)
}

#[cfg(feature = "make_md")]
fn get_top_100_template_engines() -> Result<Vec<Crate>, Error> {
    // Instantiate the client.
    let client = SyncClient::new(
        "template-benchmark-rs (the.white.wolf.is.1337@gmail.com)",
        std::time::Duration::from_millis(2000),
    )?;
    // Retrieve crate data.
    let template_engine_crates = client.from_category(String::from("template-engine"))?;
    thread::sleep(Duration::from_secs(2));

    Ok(template_engine_crates)
}

#[cfg(feature = "make_md")]
/// Parses (version, date) as available from rustc version string.
fn version_and_date_from_rustc_version(s: &str) -> (Option<String>, Option<String>) {
    let last_line = s.lines().last().unwrap_or(s);
    let mut components = last_line.trim().split(" ");
    let version = components.nth(1);
    let date = components.filter(|c| c.ends_with(')')).next().map(|s| {
        s.trim_end()
            .trim_end_matches(")")
            .trim_start()
            .trim_start_matches('(')
    });
    (version.map(|s| s.to_string()), date.map(|s| s.to_string()))
}

#[cfg(feature = "make_md")]
/// Turns crate into a row for markdown table.
fn crate_into_row(rank: Option<usize>, crate_info: &Crate) -> String {
    //let empty_string
    format!(
        "| {} | [{}]({}) | {} | {} | {} |\n",
        match rank {
            Some(num) => num.to_string(),
            None => "unranked".to_string(),
        },
        crate_info.name,
        if let Some(homepage) = &crate_info.homepage {
            homepage.as_str()
        } else if let Some(repo) = &crate_info.repository {
            repo.as_str()
        } else {
            ""
        },
        if let Some(desc) = &crate_info.description {
            desc.as_str()
        } else {
            ""
        },
        format_number(crate_info.recent_downloads.unwrap_or(0)),
        crate_info.updated_at.format("%d %B %Y")
    )
}

#[cfg(feature = "make_md")]
/// Parses (version, date) as available from rustc version string.
fn format_number(num: u64) -> String {
    let n = num.to_string();
    let mut output = String::new();
    let mut place = n.len();
    let mut later_loop = false;

    for ch in n.chars() {
        if later_loop && place % 3 == 0 {
            output.push(',');
        }

        output.push(ch);
        later_loop = true;
        place -= 1;
    };

    output
}

#[cfg(feature = "make_md")]
/// Returns (version, date) as available from `rustc --version`.
fn get_version_and_date() -> Option<(Option<String>, Option<String>)> {
    env::var("RUSTC")
        .ok()
        .and_then(|rustc| Command::new(rustc).arg("--version").output().ok())
        .or_else(|| Command::new("rustc").arg("--version").output().ok())
        .and_then(|output| String::from_utf8(output.stdout).ok())
        .map(|s| version_and_date_from_rustc_version(&s))
}
